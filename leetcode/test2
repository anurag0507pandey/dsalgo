class Solution {
public:
    double myPow(double x, int n) {
        return pow(x, n);
    }
    
private:
    double pow(double x, long n){
        if(n == 0) return 1;
        
        if(n == 1) return x;
        
        if(n < 0){
            return pow(1/x, -n);
        }
        
        double result = pow(x*x, n/2);
        
        if(n % 2 != 0){
            result *= x;
        }
        
        return result;
    }
};

/*
    Check the bounds and in cases of integer overflow;
    Two cases: n >= 0 and n < 0
    if n < 0 return pow(1/x, n);
    
    For log(n) solution, pow(x^2, n/2) if eve; if odd multiply that by x (so, x*pow(x^2, n/2))
    
    Eg: pow(2, 8):
           pow(4, 4):
              pow(16, 2)
                pow(256, 1) -> returns 256;(3 calls).

    Otherwise: pow(2, 8):
                2*pow(2, 7):
                    2*pow(2, 6):
                     2*pow(2, 5):
                      2*pow(2, 4):
                       2*pow(2, 3):
                        2*pow(2, 2):
                         2*pow(2, 1) -> returns 256(7 calls)
                         
    So in general, brute force technique does (2^n-1) calls wheres optimised solution does
    log n calls(waay better) :)
*/
